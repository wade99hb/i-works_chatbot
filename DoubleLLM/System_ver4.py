import streamlit as st
import pandas as pd
import ollama
import warnings
import pymysql
import time
import re
import matplotlib.pyplot as plt
import plotly.express as px
from datetime import datetime
from PIL import Image
import plotly.graph_objects as go
import uuid
import html # Import html module for escaping

# --- Database Connection ---
# Consider using st.connection for better handling in Streamlit
try:
    db = pymysql.connect(
        host='localhost',
        port=3306,
        user='root',
        passwd='jeminist1029', # Be cautious with hardcoding passwords
        db='zabbix_ver1',
        charset='utf8'
    )
    cursor = db.cursor()
except pymysql.Error as e:
    st.error(f"DB ì—°ê²° ì˜¤ë¥˜: {e}")
    st.stop() # Stop execution if DB connection fails

#-------------------------------------------------------------------------
# Functions (kept as is, assuming they work correctly)
# íŠ¹ì • columnì˜ íŠ¹ì • ê°’somethingì´ ìˆëŠ” í–‰ë“¤ì„ ì°¾ëŠ” sqlë¬¸ì„ ë§Œë“œëŠ” í•¨ìˆ˜
def FindSomething(table_name,column_name,something):
  table_name = 'history_uint' if table_name == '*' else table_name
  if column_name=='*' or something=='*':
    # Consider raising an error instead of just warning
    return warnings.warn('Given input include '*'')
  sql = f'''
    SELECT *
    FROM {table_name}
    WHERE {column_name} = {something}
  '''
  return sql

#í‚¤ì›Œë“œë¡œ hostid ê²°ì • (This function uses input(), which won't work directly in Streamlit)
# You'll need to replace this with Streamlit widgets (e.g., st.text_input, st.selectbox)
# For now, we are using the hardcoded hostid=11172
# def find_hostid(host_list_df):
#   keywords = input("ì°¾ê³  ì‹¶ì€ ì„œë²„ì— ëŒ€í•œ í‚¤ì›Œë“œ ì…ë ¥: ")
#   rows_contain_keywords = host_list_df[host_list_df['result__name'].str.contains(keywords)]
#   print(rows_contain_keywords['result__name'])
#   choosen = int(input("ì›í•˜ëŠ” ì„œë²„ì˜ ì¸ë±ìŠ¤ ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ ì£¼ì‹­ì‹œì˜¤"))
#   result = host_list_df.iloc[choosen]['result__hostid']
#   print(f"{host_list_df.iloc[choosen]['result__name']}ì˜ hostidëŠ” {result}ì…ë‹ˆë‹¤.")
#   return int(result)

def does_it_exist(conn, table,itemid):
    cur = conn.cursor()
    query = f"""
        SELECT EXISTS(
            SELECT 1
            FROM {table}
            WHERE itemid = %s  # Use parameterized query
        ) AS row_exists;
    """
    try:
        cur.execute(query, (itemid,))
        result = cur.fetchone()[0]
    except pymysql.Error as e:
        st.error(f"DB ì˜¤ë¥˜ (does_it_exist): {e}")
        result = 0 # Assume not exists on error
    finally:
        cur.close()
    return bool(result)

def exist_data(conn, itemid):
    if does_it_exist(conn, 'history',itemid):
        return 1
    elif does_it_exist(conn,'history_uint',itemid):
        return 2
    else:
        return 0

def check_sql_syntax(sql):
    temp_cursor = db.cursor()
    try:
        # Add LIMIT 1 to EXPLAIN to prevent potential long execution
        #temp_cursor.execute(f"EXPLAIN {sql.strip().rstrip(';')}") # Basic check
        temp_cursor.execute(f"EXPLAIN {sql}")
        return True
    except pymysql.Error as e:
        print(f"SQL ë¬¸ë²• ì˜¤ë¥˜ ê°ì§€: {e}") # Log for debugging
        return False
    finally:
        temp_cursor.close()


def make_tablecode_right(sql, dic):
    # Improved regex to be more robust
    itemid_match = re.search(r'itemid\s*=\s*(\d+)', sql, re.IGNORECASE)
    table_match = re.search(r'FROM\s+`?(\w+)`?', sql, re.IGNORECASE) # Handle optional backticks

    if not itemid_match or not table_match:
        return False, "âŒ SQLì—ì„œ itemid ë˜ëŠ” í…Œì´ë¸”ëª…ì„ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

    itemid = itemid_match.group(1)
    table_name_in_sql = table_match.group(1).lower() # Normalize to lowercase

    # Find the expected table based on the dictionary
    expected_table = None
    for key, value in dic.items():
        try:
            tablecode, dic_itemid = value.split('_')
            if dic_itemid == itemid:
                expected_table = "history" if tablecode == "1" else "history_uint"
                break # Found the itemid in dict
        except ValueError:
            print(f"Warning: Invalid format in dic for key '{key}': '{value}'")
            continue # Skip malformed dictionary entries

    if expected_table is None:
        return False, f"âŒ itemid {itemid}ë¥¼ ì‚¬ì „(dic)ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

    # Check if table name matches and correct if necessary
    if expected_table == table_name_in_sql:
        return True, sql # Table name is already correct
    else:
        # Attempt to correct the table name in the SQL string
        # This is fragile; depends heavily on SQL structure generated by LLM
        try:
            # Case-insensitive replacement
            corrected_sql = re.sub(f'FROM\s+`?{table_name_in_sql}`?', f'FROM {expected_table}', sql, flags=re.IGNORECASE, count=1)
            if corrected_sql == sql: # If replacement didn't happen (e.g., complex SQL)
                 return False, f"âŒ í…Œì´ë¸”ëª… ìë™ ìˆ˜ì • ì‹¤íŒ¨: ì˜ˆìƒ({expected_table}), SQL ë‚´({table_name_in_sql})"
            print(f"Info: Corrected table name from {table_name_in_sql} to {expected_table}")
            return True, corrected_sql
        except Exception as e:
            return False, f"âŒ í…Œì´ë¸”ëª… ìë™ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}"

# --- End of Functions ---

# --- Load Initial Data (Consider caching with @st.cache_data) ---
@st.cache_data # Cache data loading
def load_data():
    try:
        host_list_df = pd.read_excel("C:\CCraft\i-works\Data\zabbix_host_ëª©ë¡_2.xlsx")
        # x_df = pd.read_excel(r"C:\Users\user\Documents\GitHub\i-works_chatbot\DoubleLLM\graph.xlsx") # Only load if needed
    except FileNotFoundError as e:
        st.error(f"íŒŒì¼ ë¡œë”© ì˜¤ë¥˜: {e}")
        return None, None
    return host_list_df #, x_df

host_list_df = load_data()
if host_list_df is None:
    st.stop()

# --- Session State Initialization ---
if 'messages' not in st.session_state:
    st.session_state.messages = []
if 'current_hostid' not in st.session_state:
    st.session_state['current_hostid'] = 11172 # Default hostid
if 'current_hostname' not in st.session_state:
     # Fetch hostname based on default hostid
     try:
         st.session_state['current_hostname'] = host_list_df[host_list_df['result__hostid'] == st.session_state['current_hostid']]['result__name'].iloc[0]
     except IndexError:
         st.session_state['current_hostname'] = "ì•Œ ìˆ˜ ì—†ëŠ” í˜¸ìŠ¤íŠ¸"


# --- Host Selection (Example - replace with your actual selection logic if needed) ---
# You might want a dropdown or search bar to select the host
# selected_host = st.selectbox("í˜¸ìŠ¤íŠ¸ ì„ íƒ", host_list_df['result__name'])
# if selected_host:
#     selected_host_info = host_list_df[host_list_df['result__name'] == selected_host].iloc[0]
#     st.session_state['current_hostid'] = int(selected_host_info['result__hostid'])
#     st.session_state['current_hostname'] = selected_host_info['result__name']

# --- Fetch Item Data for Current Host (Consider caching) ---
@st.cache_data # Cache data based on hostid
def get_items_for_host(hostid):
    items_dict = {}
    query_from_hostid = FindSomething('items', 'hostid', hostid)
    if isinstance(query_from_hostid, warnings.WarningMessage): # Check if FindSomething warned
        st.error("í˜¸ìŠ¤íŠ¸ ì•„ì´í…œ ì¡°íšŒ SQL ìƒì„± ì˜¤ë¥˜.")
        return items_dict

    try:
        temp_cursor = db.cursor()
        temp_cursor.execute("SELECT itemid, name FROM items WHERE hostid = %s", (hostid,))
        items_result = temp_cursor.fetchall()

        items_column_names_simple = ['itemid', 'name'] # Only fetch needed columns
        df_from_hostid = pd.DataFrame(items_result, columns=items_column_names_simple)

        # Build the dictionary efficiently
        for index, row in df_from_hostid.iterrows():
            itemid = row['itemid']
            name = str(row['name'])
            checker = exist_data(db, itemid) # Check which history table
            if checker == 1:
                items_dict[name] = f'1_{itemid}'
            elif checker == 2:
                items_dict[name] = f'2_{itemid}'
        temp_cursor.close()

    except pymysql.Error as e:
        st.error(f"í˜¸ìŠ¤íŠ¸ ì•„ì´í…œ ì¡°íšŒ ì¤‘ DB ì˜¤ë¥˜ ë°œìƒ: {e}")
    except Exception as e:
        st.error(f"í˜¸ìŠ¤íŠ¸ ì•„ì´í…œ ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}")

    return items_dict

# Get item dictionary for the selected host
dic = get_items_for_host(st.session_state['current_hostid'])
if not dic:
    st.warning(f"í˜¸ìŠ¤íŠ¸ ID {st.session_state['current_hostid']}ì— ëŒ€í•œ ì•„ì´í…œ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. DB ì—°ê²° ë˜ëŠ” ë°ì´í„° í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.")
    # Optionally provide a default empty dict or stop
    # dic = {}


# --- UI Layout ---
st.title("ğŸŸ¡ i-Works Chat-Bot ğŸŸ¡")
st.write('### ë¬´ì—‡ì´ë“  ë¬¼ì–´ë³´ì„¸ìš”!')
st.write(f"í˜„ì¬ ì„œë²„: **{st.session_state['current_hostname']}** (hostid: {st.session_state['current_hostid']})")

# --- CSS for Chat Window ---
st.markdown("""
<style>
    /* Main chat container */
    .chat-container {
        height: 500px; /* Fixed height */
        overflow-y: auto; /* Enable vertical scroll */
        display: flex;
        flex-direction: column-reverse; /* Newest messages at the bottom */
        border: 1px solid #e0e0e0;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px; /* Space before input */
        background-color: #ffffff; /* Optional: background color */
    }

    /* Individual message bubble styling */
    .message-bubble {
        padding: 10px 15px;
        border-radius: 18px;
        margin-bottom: 10px;
        max-width: 75%; /* Max width of a bubble */
        word-wrap: break-word; /* Wrap long words */
        clear: both; /* Ensure bubbles don't overlap weirdly */
        line-height: 1.4;
    }

    /* User message styling */
    .user-bubble {
        background-color: #DCF8C6; /* Light green */
        color: black;
        align-self: flex-end; /* Align to the right */
        text-align: left; /* Align text inside bubble left */
        margin-left: auto; /* Push to the right */
    }

    /* AI message styling */
    .ai-bubble {
        background-color: #F1F0F0; /* Light grey */
        color: black;
        align-self: flex-start; /* Align to the left */
        text-align: left;
        margin-right: auto; /* Push to the left */
    }

    /* Ensure Streamlit elements like plots inside the container don't break layout */
    .chat-container .stPlotlyChart {
        margin-top: 5px;
        max-width: 100%; /* Fit plot to bubble width */
    }

    /* Style for the input area below the chat */
    .stTextInput, .stButton > button {
        margin-top: 10px;
    }
</style>
""", unsafe_allow_html=True)

# --- Chat History Display Area ---
# This container will hold the styled div for scrolling
chat_display_area = st.container()

with chat_display_area:
    st.markdown('<div class="chat-container">', unsafe_allow_html=True)

    # Inner container to hold the actual messages and plots dynamically
    message_placeholder = st.container()
    with message_placeholder:
        for i, msg in enumerate(st.session_state.messages):
            is_user = msg['role'] == 'user'
            bubble_class = "user-bubble" if is_user else "ai-bubble"

            # Safely escape content to prevent HTML injection
            escaped_content = html.escape(msg['content'])

            st.markdown(
                f"<div class='message-bubble {bubble_class}'>{escaped_content}</div>",
                unsafe_allow_html=True,
                key=f"msg_{i}_{msg['role']}" # Unique key for each message
            )

            # Display plot if it's an AI message and a figure exists
            if not is_user and 'fig' in msg and msg['fig'] is not None:
                # Display plot below the AI text bubble
                # Use unique key combining index and a short uuid
                plot_key = f"plot_{i}_{str(uuid.uuid4())[:8]}"
                st.plotly_chart(msg['fig'], use_container_width=True, key=plot_key)

    st.markdown('</div>', unsafe_allow_html=True) # Close the chat-container div

# --- User Input Form ---
# Place the form *outside* and *after* the chat display area
with st.form(key="chat_form", clear_on_submit=True):
    user_input = st.text_input(
        "ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”:",
        key="input_text",
        placeholder="ì—¬ê¸°ì— ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ê³  Enter ë˜ëŠ” ì „ì†¡ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”...",
        label_visibility="collapsed" # Hide the label "ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”:"
    )
    submitted = st.form_submit_button("ì „ì†¡")

# --- Message Processing Logic ---
if submitted and user_input:
    # 1. Add user message to history
    st.session_state.messages.append({"role": "user", "content": user_input})

    # 2. Prepare prompt for LLM
    prompt = {
        'Users_Question': user_input,
        'Searchable_infomation' : dic, # Send the item dictionary
        'Time_now' : time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    }

    # 3. Call LLM (add error handling)
    try:
        response = ollama.chat(model='Making_Query_version6', messages=[
            {'role': 'user', 'content': str(prompt)},
        ])
        llm_result_sql = response['message']['content'].strip()
        print("^^^^^^^^^^^^^^LLM Result (SQL Query)^^^^^^^^^^^^^^")
        print(llm_result_sql)
        print("^^^^^^^^^^^^^^LLM Result (SQL Query)^^^^^^^^^^^^^^")

        # 4. Validate and Correct SQL
        is_valid_syntax = check_sql_syntax(llm_result_sql)
        is_correct_mapping, corrected_sql = make_tablecode_right(llm_result_sql, dic)

        ai_response_content = ""
        fig = None

        if is_valid_syntax and is_correct_mapping:
            print(f"Info: Using SQL: {corrected_sql}")
            # TODO: Replace hardcoded time with dynamic time based on user input or context
            # This requires the LLM to understand timeframes or asking the user.
            # For now, using a placeholder wide range for testing.
            # A better approach is needed for real use.
            # Example: Extract time from user_input if possible, or use recent data.
            # time_condition = "WHERE clock >= UNIX_TIMESTAMP(NOW() - INTERVAL 1 DAY)" # Example: Last 1 day

            # --- DANGER ZONE: Directly executing LLM SQL ---
            # Be EXTREMELY cautious executing LLM-generated SQL directly.
            # Implement strict validation, allowlisting, or sandboxing.
            # The current validation is basic.

            # Let's try to extract the time range from the corrected SQL first
            # Basic time range extraction (might need adjustment based on LLM output format)
            time_match = re.search(r"clock\s*BETWEEN\s*'?(\d+)'?\s*AND\s*'?(\d+)'?", corrected_sql, re.IGNORECASE)
            if time_match:
                 # Keep the original time range from LLM if present
                 final_sql = corrected_sql
            else:
                 # If no time range found, add a default (e.g., last hour) - ADJUST AS NEEDED
                 # Using UNIX timestamps as in Zabbix history tables
                 end_time = int(time.time())
                 start_time = end_time - 3600 # 1 hour ago
                 time_clause = f" WHERE clock BETWEEN {start_time} AND {end_time}"

                 # Try to intelligently add the WHERE clause or append to existing one
                 if "WHERE" in corrected_sql.upper():
                      # Append condition - This is complex and error-prone, LLM should ideally include time
                      # For now, we might overwrite or append crudely - needs robust parsing
                      if "ORDER BY" in corrected_sql.upper():
                          final_sql = re.sub("ORDER BY", f" AND clock BETWEEN {start_time} AND {end_time} ORDER BY", corrected_sql, flags=re.IGNORECASE, count=1)
                      elif "LIMIT" in corrected_sql.upper():
                           final_sql = re.sub("LIMIT", f" AND clock BETWEEN {start_time} AND {end_time} LIMIT", corrected_sql, flags=re.IGNORECASE, count=1)
                      else:
                           final_sql = corrected_sql.rstrip(";") + f" AND clock BETWEEN {start_time} AND {end_time};"
                 else:
                      # Add WHERE clause
                       if "ORDER BY" in corrected_sql.upper():
                          final_sql = re.sub("ORDER BY", f" WHERE clock BETWEEN {start_time} AND {end_time} ORDER BY", corrected_sql, flags=re.IGNORECASE, count=1)
                       elif "LIMIT" in corrected_sql.upper():
                           final_sql = re.sub("LIMIT", f" WHERE clock BETWEEN {start_time} AND {end_time} LIMIT", corrected_sql, flags=re.IGNORECASE, count=1)
                       else:
                            final_sql = corrected_sql.rstrip(";") + f" WHERE clock BETWEEN {start_time} AND {end_time};"
            
            print("@@@@@@@@@@@@@@@@ Final SQL @@@@@@@@@@@@@@@@")
            print(final_sql)
            print("@@@@@@@@@@@@@@@@ Final SQL @@@@@@@@@@@@@@@@")


            try:
                temp_cursor = db.cursor()
                # Execute the potentially corrected and time-adjusted SQL
                temp_cursor.execute(final_sql)
                result = temp_cursor.fetchall()
                temp_cursor.close()

                if result:
                    # Assuming columns are itemid, value, clock based on original code
                    # Adapt column names if your LLM/query returns different ones
                    df = pd.DataFrame(result, columns=['itemid', 'value', 'clock'])
                    
                    # Convert Unix timestamp 'clock' to datetime
                    df['clock'] = pd.to_datetime(df['clock'], unit='s') 
                    df = df.sort_values(by='clock') # Ensure data is sorted by time

                    # Get indicator name and units
                    itemid_of_indicator = df.iloc[0]['itemid']
                    name_of_indicator = "Unknown Indicator"
                    for name, value in dic.items():
                        if str(itemid_of_indicator) in value:
                            name_of_indicator = name
                            break
                    
                    unit_of_pointer = ""
                    try:
                         temp_cursor_unit = db.cursor()
                         temp_cursor_unit.execute("SELECT units FROM items WHERE itemid = %s", (itemid_of_indicator,))
                         unit_result = temp_cursor_unit.fetchone()
                         if unit_result and unit_result[0]:
                             unit_of_pointer = f" ({unit_result[0]})" # Add space and parentheses
                         temp_cursor_unit.close()
                    except pymysql.Error as e:
                        print(f"Warning: Could not fetch units for itemid {itemid_of_indicator}: {e}")


                    # Calculate time difference correctly
                    if len(df) > 1:
                         time_delta = df['clock'].iloc[-1] - df['clock'].iloc[0]
                         total_seconds = time_delta.total_seconds()
                         hours = int(total_seconds // 3600)
                         minutes = int((total_seconds % 3600) // 60)
                         timeset_str = f"{hours}ì‹œê°„ {minutes}ë¶„"
                    else:
                         timeset_str = "ë‹¨ì¼ ì‹œì "

                    df_describe = df['value'].astype(float).describe() # Ensure value is float for describe

                    # Format the descriptive answer
                    ai_response_content = (
                        f"{timeset_str} ë™ì•ˆì˜ '{name_of_indicator}' ì§€í‘œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤{unit_of_pointer}:\n"
                        f"- í‰ê· : {df_describe.get('mean', 'N/A'):.2f}\n"
                        f"- í‘œì¤€í¸ì°¨: {df_describe.get('std', 'N/A'):.2f}\n"
                        f"- ìµœëŒ€ê°’: {df_describe.get('max', 'N/A'):.2f}\n"
                        f"- ìµœì†Œê°’: {df_describe.get('min', 'N/A'):.2f}"
                    )

                    # Create plot
                    fig = px.line(df, x='clock', y='value', title=f'{name_of_indicator} ì‹œê³„ì—´ ë°ì´í„°')
                    fig.update_layout(height=300, xaxis_title="ì‹œê°„", yaxis_title=f"ê°’{unit_of_pointer}")

                else:
                    ai_response_content = "í•´ë‹¹ ì¡°ê±´ì— ë§ëŠ” ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

            except pymysql.Error as e:
                print(f"DB ì‹¤í–‰ ì˜¤ë¥˜: {e}")
                ai_response_content = f"ë°ì´í„° ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}"
            except Exception as e:
                print(f"ë°ì´í„° ì²˜ë¦¬/í”Œë¡œíŒ… ì˜¤ë¥˜: {e}")
                ai_response_content = f"ê²°ê³¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}"

        elif not is_correct_mapping:
             ai_response_content = f"SQL ìƒì„± ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {corrected_sql}" # Show error from make_tablecode_right
        else: # Not valid syntax or other issue
             ai_response_content = "ì£„ì†¡í•˜ì§€ë§Œ, ìœ íš¨í•œ SQL ì¿¼ë¦¬ë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì§ˆë¬¸ì„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì‹œê² ì–´ìš”?"
             # Optionally create a default placeholder graph if needed
             # fig = go.Figure(...) # Your placeholder graph code

    except Exception as e:
        print(f"LLM í˜¸ì¶œ ë˜ëŠ” ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {e}")
        st.error(f"LLM í†µì‹  ë˜ëŠ” ì‘ë‹µ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        ai_response_content = "ì£„ì†¡í•©ë‹ˆë‹¤, ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
        fig = None

    # 5. Add AI response to history
    ai_message = {"role": "ai", "content": ai_response_content}
    if fig is not None:
        ai_message["fig"] = fig
    st.session_state.messages.append(ai_message)

    # 6. Rerun the script to update the UI immediately
    st.rerun()


# --- Close DB connection on script exit (optional but good practice) ---
# This part might not execute reliably in Streamlit's execution model
# Using st.connection is generally preferred for managing resources.
# def cleanup():
#     if 'db' in globals() and db.open:
#         db.close()
#         print("DB connection closed.")
# import atexit
# atexit.register(cleanup)
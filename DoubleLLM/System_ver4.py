import streamlit as st
import pandas as pd
import ollama
import warnings
import pymysql
import time
import re
import matplotlib.pyplot as plt
import plotly.express as px
from datetime import datetime
from PIL import Image
import plotly.graph_objects as go
import uuid
import html # Import html module for escaping

# --- Database Connection ---
# Consider using st.connection for better handling in Streamlit
try:
    db = pymysql.connect(
        host='localhost',
        port=3306,
        user='root',
        passwd='jeminist1029', # Be cautious with hardcoding passwords
        db='zabbix_ver1',
        charset='utf8'
    )
    cursor = db.cursor()
except pymysql.Error as e:
    st.error(f"DB 연결 오류: {e}")
    st.stop() # Stop execution if DB connection fails

#-------------------------------------------------------------------------
# Functions (kept as is, assuming they work correctly)
# 특정 column의 특정 값something이 있는 행들을 찾는 sql문을 만드는 함수
def FindSomething(table_name,column_name,something):
  table_name = 'history_uint' if table_name == '*' else table_name
  if column_name=='*' or something=='*':
    # Consider raising an error instead of just warning
    return warnings.warn('Given input include '*'')
  sql = f'''
    SELECT *
    FROM {table_name}
    WHERE {column_name} = {something}
  '''
  return sql

#키워드로 hostid 결정 (This function uses input(), which won't work directly in Streamlit)
# You'll need to replace this with Streamlit widgets (e.g., st.text_input, st.selectbox)
# For now, we are using the hardcoded hostid=11172
# def find_hostid(host_list_df):
#   keywords = input("찾고 싶은 서버에 대한 키워드 입력: ")
#   rows_contain_keywords = host_list_df[host_list_df['result__name'].str.contains(keywords)]
#   print(rows_contain_keywords['result__name'])
#   choosen = int(input("원하는 서버의 인덱스 번호를 입력해 주십시오"))
#   result = host_list_df.iloc[choosen]['result__hostid']
#   print(f"{host_list_df.iloc[choosen]['result__name']}의 hostid는 {result}입니다.")
#   return int(result)

def does_it_exist(conn, table,itemid):
    cur = conn.cursor()
    query = f"""
        SELECT EXISTS(
            SELECT 1
            FROM {table}
            WHERE itemid = %s  # Use parameterized query
        ) AS row_exists;
    """
    try:
        cur.execute(query, (itemid,))
        result = cur.fetchone()[0]
    except pymysql.Error as e:
        st.error(f"DB 오류 (does_it_exist): {e}")
        result = 0 # Assume not exists on error
    finally:
        cur.close()
    return bool(result)

def exist_data(conn, itemid):
    if does_it_exist(conn, 'history',itemid):
        return 1
    elif does_it_exist(conn,'history_uint',itemid):
        return 2
    else:
        return 0

def check_sql_syntax(sql):
    temp_cursor = db.cursor()
    try:
        # Add LIMIT 1 to EXPLAIN to prevent potential long execution
        #temp_cursor.execute(f"EXPLAIN {sql.strip().rstrip(';')}") # Basic check
        temp_cursor.execute(f"EXPLAIN {sql}")
        return True
    except pymysql.Error as e:
        print(f"SQL 문법 오류 감지: {e}") # Log for debugging
        return False
    finally:
        temp_cursor.close()


def make_tablecode_right(sql, dic):
    # Improved regex to be more robust
    itemid_match = re.search(r'itemid\s*=\s*(\d+)', sql, re.IGNORECASE)
    table_match = re.search(r'FROM\s+`?(\w+)`?', sql, re.IGNORECASE) # Handle optional backticks

    if not itemid_match or not table_match:
        return False, "❌ SQL에서 itemid 또는 테이블명을 파싱할 수 없습니다."

    itemid = itemid_match.group(1)
    table_name_in_sql = table_match.group(1).lower() # Normalize to lowercase

    # Find the expected table based on the dictionary
    expected_table = None
    for key, value in dic.items():
        try:
            tablecode, dic_itemid = value.split('_')
            if dic_itemid == itemid:
                expected_table = "history" if tablecode == "1" else "history_uint"
                break # Found the itemid in dict
        except ValueError:
            print(f"Warning: Invalid format in dic for key '{key}': '{value}'")
            continue # Skip malformed dictionary entries

    if expected_table is None:
        return False, f"❌ itemid {itemid}를 사전(dic)에서 찾을 수 없습니다."

    # Check if table name matches and correct if necessary
    if expected_table == table_name_in_sql:
        return True, sql # Table name is already correct
    else:
        # Attempt to correct the table name in the SQL string
        # This is fragile; depends heavily on SQL structure generated by LLM
        try:
            # Case-insensitive replacement
            corrected_sql = re.sub(f'FROM\s+`?{table_name_in_sql}`?', f'FROM {expected_table}', sql, flags=re.IGNORECASE, count=1)
            if corrected_sql == sql: # If replacement didn't happen (e.g., complex SQL)
                 return False, f"❌ 테이블명 자동 수정 실패: 예상({expected_table}), SQL 내({table_name_in_sql})"
            print(f"Info: Corrected table name from {table_name_in_sql} to {expected_table}")
            return True, corrected_sql
        except Exception as e:
            return False, f"❌ 테이블명 자동 수정 중 오류 발생: {e}"

# --- End of Functions ---

# --- Load Initial Data (Consider caching with @st.cache_data) ---
@st.cache_data # Cache data loading
def load_data():
    try:
        host_list_df = pd.read_excel("C:\CCraft\i-works\Data\zabbix_host_목록_2.xlsx")
        # x_df = pd.read_excel(r"C:\Users\user\Documents\GitHub\i-works_chatbot\DoubleLLM\graph.xlsx") # Only load if needed
    except FileNotFoundError as e:
        st.error(f"파일 로딩 오류: {e}")
        return None, None
    return host_list_df #, x_df

host_list_df = load_data()
if host_list_df is None:
    st.stop()

# --- Session State Initialization ---
if 'messages' not in st.session_state:
    st.session_state.messages = []
if 'current_hostid' not in st.session_state:
    st.session_state['current_hostid'] = 11172 # Default hostid
if 'current_hostname' not in st.session_state:
     # Fetch hostname based on default hostid
     try:
         st.session_state['current_hostname'] = host_list_df[host_list_df['result__hostid'] == st.session_state['current_hostid']]['result__name'].iloc[0]
     except IndexError:
         st.session_state['current_hostname'] = "알 수 없는 호스트"


# --- Host Selection (Example - replace with your actual selection logic if needed) ---
# You might want a dropdown or search bar to select the host
# selected_host = st.selectbox("호스트 선택", host_list_df['result__name'])
# if selected_host:
#     selected_host_info = host_list_df[host_list_df['result__name'] == selected_host].iloc[0]
#     st.session_state['current_hostid'] = int(selected_host_info['result__hostid'])
#     st.session_state['current_hostname'] = selected_host_info['result__name']

# --- Fetch Item Data for Current Host (Consider caching) ---
@st.cache_data # Cache data based on hostid
def get_items_for_host(hostid):
    items_dict = {}
    query_from_hostid = FindSomething('items', 'hostid', hostid)
    if isinstance(query_from_hostid, warnings.WarningMessage): # Check if FindSomething warned
        st.error("호스트 아이템 조회 SQL 생성 오류.")
        return items_dict

    try:
        temp_cursor = db.cursor()
        temp_cursor.execute("SELECT itemid, name FROM items WHERE hostid = %s", (hostid,))
        items_result = temp_cursor.fetchall()

        items_column_names_simple = ['itemid', 'name'] # Only fetch needed columns
        df_from_hostid = pd.DataFrame(items_result, columns=items_column_names_simple)

        # Build the dictionary efficiently
        for index, row in df_from_hostid.iterrows():
            itemid = row['itemid']
            name = str(row['name'])
            checker = exist_data(db, itemid) # Check which history table
            if checker == 1:
                items_dict[name] = f'1_{itemid}'
            elif checker == 2:
                items_dict[name] = f'2_{itemid}'
        temp_cursor.close()

    except pymysql.Error as e:
        st.error(f"호스트 아이템 조회 중 DB 오류 발생: {e}")
    except Exception as e:
        st.error(f"호스트 아이템 처리 중 예외 발생: {e}")

    return items_dict

# Get item dictionary for the selected host
dic = get_items_for_host(st.session_state['current_hostid'])
if not dic:
    st.warning(f"호스트 ID {st.session_state['current_hostid']}에 대한 아이템 정보를 찾을 수 없습니다. DB 연결 또는 데이터 확인이 필요합니다.")
    # Optionally provide a default empty dict or stop
    # dic = {}


# --- UI Layout ---
st.title("🟡 i-Works Chat-Bot 🟡")
st.write('### 무엇이든 물어보세요!')
st.write(f"현재 서버: **{st.session_state['current_hostname']}** (hostid: {st.session_state['current_hostid']})")

# --- CSS for Chat Window ---
st.markdown("""
<style>
    /* Main chat container */
    .chat-container {
        height: 500px; /* Fixed height */
        overflow-y: auto; /* Enable vertical scroll */
        display: flex;
        flex-direction: column-reverse; /* Newest messages at the bottom */
        border: 1px solid #e0e0e0;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px; /* Space before input */
        background-color: #ffffff; /* Optional: background color */
    }

    /* Individual message bubble styling */
    .message-bubble {
        padding: 10px 15px;
        border-radius: 18px;
        margin-bottom: 10px;
        max-width: 75%; /* Max width of a bubble */
        word-wrap: break-word; /* Wrap long words */
        clear: both; /* Ensure bubbles don't overlap weirdly */
        line-height: 1.4;
    }

    /* User message styling */
    .user-bubble {
        background-color: #DCF8C6; /* Light green */
        color: black;
        align-self: flex-end; /* Align to the right */
        text-align: left; /* Align text inside bubble left */
        margin-left: auto; /* Push to the right */
    }

    /* AI message styling */
    .ai-bubble {
        background-color: #F1F0F0; /* Light grey */
        color: black;
        align-self: flex-start; /* Align to the left */
        text-align: left;
        margin-right: auto; /* Push to the left */
    }

    /* Ensure Streamlit elements like plots inside the container don't break layout */
    .chat-container .stPlotlyChart {
        margin-top: 5px;
        max-width: 100%; /* Fit plot to bubble width */
    }

    /* Style for the input area below the chat */
    .stTextInput, .stButton > button {
        margin-top: 10px;
    }
</style>
""", unsafe_allow_html=True)

# --- Chat History Display Area ---
# This container will hold the styled div for scrolling
chat_display_area = st.container()

with chat_display_area:
    st.markdown('<div class="chat-container">', unsafe_allow_html=True)

    # Inner container to hold the actual messages and plots dynamically
    message_placeholder = st.container()
    with message_placeholder:
        for i, msg in enumerate(st.session_state.messages):
            is_user = msg['role'] == 'user'
            bubble_class = "user-bubble" if is_user else "ai-bubble"

            # Safely escape content to prevent HTML injection
            escaped_content = html.escape(msg['content'])

            st.markdown(
                f"<div class='message-bubble {bubble_class}'>{escaped_content}</div>",
                unsafe_allow_html=True,
                key=f"msg_{i}_{msg['role']}" # Unique key for each message
            )

            # Display plot if it's an AI message and a figure exists
            if not is_user and 'fig' in msg and msg['fig'] is not None:
                # Display plot below the AI text bubble
                # Use unique key combining index and a short uuid
                plot_key = f"plot_{i}_{str(uuid.uuid4())[:8]}"
                st.plotly_chart(msg['fig'], use_container_width=True, key=plot_key)

    st.markdown('</div>', unsafe_allow_html=True) # Close the chat-container div

# --- User Input Form ---
# Place the form *outside* and *after* the chat display area
with st.form(key="chat_form", clear_on_submit=True):
    user_input = st.text_input(
        "메시지를 입력하세요:",
        key="input_text",
        placeholder="여기에 메시지를 입력하고 Enter 또는 전송 버튼을 누르세요...",
        label_visibility="collapsed" # Hide the label "메시지를 입력하세요:"
    )
    submitted = st.form_submit_button("전송")

# --- Message Processing Logic ---
if submitted and user_input:
    # 1. Add user message to history
    st.session_state.messages.append({"role": "user", "content": user_input})

    # 2. Prepare prompt for LLM
    prompt = {
        'Users_Question': user_input,
        'Searchable_infomation' : dic, # Send the item dictionary
        'Time_now' : time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    }

    # 3. Call LLM (add error handling)
    try:
        response = ollama.chat(model='Making_Query_version6', messages=[
            {'role': 'user', 'content': str(prompt)},
        ])
        llm_result_sql = response['message']['content'].strip()
        print("^^^^^^^^^^^^^^LLM Result (SQL Query)^^^^^^^^^^^^^^")
        print(llm_result_sql)
        print("^^^^^^^^^^^^^^LLM Result (SQL Query)^^^^^^^^^^^^^^")

        # 4. Validate and Correct SQL
        is_valid_syntax = check_sql_syntax(llm_result_sql)
        is_correct_mapping, corrected_sql = make_tablecode_right(llm_result_sql, dic)

        ai_response_content = ""
        fig = None

        if is_valid_syntax and is_correct_mapping:
            print(f"Info: Using SQL: {corrected_sql}")
            # TODO: Replace hardcoded time with dynamic time based on user input or context
            # This requires the LLM to understand timeframes or asking the user.
            # For now, using a placeholder wide range for testing.
            # A better approach is needed for real use.
            # Example: Extract time from user_input if possible, or use recent data.
            # time_condition = "WHERE clock >= UNIX_TIMESTAMP(NOW() - INTERVAL 1 DAY)" # Example: Last 1 day

            # --- DANGER ZONE: Directly executing LLM SQL ---
            # Be EXTREMELY cautious executing LLM-generated SQL directly.
            # Implement strict validation, allowlisting, or sandboxing.
            # The current validation is basic.

            # Let's try to extract the time range from the corrected SQL first
            # Basic time range extraction (might need adjustment based on LLM output format)
            time_match = re.search(r"clock\s*BETWEEN\s*'?(\d+)'?\s*AND\s*'?(\d+)'?", corrected_sql, re.IGNORECASE)
            if time_match:
                 # Keep the original time range from LLM if present
                 final_sql = corrected_sql
            else:
                 # If no time range found, add a default (e.g., last hour) - ADJUST AS NEEDED
                 # Using UNIX timestamps as in Zabbix history tables
                 end_time = int(time.time())
                 start_time = end_time - 3600 # 1 hour ago
                 time_clause = f" WHERE clock BETWEEN {start_time} AND {end_time}"

                 # Try to intelligently add the WHERE clause or append to existing one
                 if "WHERE" in corrected_sql.upper():
                      # Append condition - This is complex and error-prone, LLM should ideally include time
                      # For now, we might overwrite or append crudely - needs robust parsing
                      if "ORDER BY" in corrected_sql.upper():
                          final_sql = re.sub("ORDER BY", f" AND clock BETWEEN {start_time} AND {end_time} ORDER BY", corrected_sql, flags=re.IGNORECASE, count=1)
                      elif "LIMIT" in corrected_sql.upper():
                           final_sql = re.sub("LIMIT", f" AND clock BETWEEN {start_time} AND {end_time} LIMIT", corrected_sql, flags=re.IGNORECASE, count=1)
                      else:
                           final_sql = corrected_sql.rstrip(";") + f" AND clock BETWEEN {start_time} AND {end_time};"
                 else:
                      # Add WHERE clause
                       if "ORDER BY" in corrected_sql.upper():
                          final_sql = re.sub("ORDER BY", f" WHERE clock BETWEEN {start_time} AND {end_time} ORDER BY", corrected_sql, flags=re.IGNORECASE, count=1)
                       elif "LIMIT" in corrected_sql.upper():
                           final_sql = re.sub("LIMIT", f" WHERE clock BETWEEN {start_time} AND {end_time} LIMIT", corrected_sql, flags=re.IGNORECASE, count=1)
                       else:
                            final_sql = corrected_sql.rstrip(";") + f" WHERE clock BETWEEN {start_time} AND {end_time};"
            
            print("@@@@@@@@@@@@@@@@ Final SQL @@@@@@@@@@@@@@@@")
            print(final_sql)
            print("@@@@@@@@@@@@@@@@ Final SQL @@@@@@@@@@@@@@@@")


            try:
                temp_cursor = db.cursor()
                # Execute the potentially corrected and time-adjusted SQL
                temp_cursor.execute(final_sql)
                result = temp_cursor.fetchall()
                temp_cursor.close()

                if result:
                    # Assuming columns are itemid, value, clock based on original code
                    # Adapt column names if your LLM/query returns different ones
                    df = pd.DataFrame(result, columns=['itemid', 'value', 'clock'])
                    
                    # Convert Unix timestamp 'clock' to datetime
                    df['clock'] = pd.to_datetime(df['clock'], unit='s') 
                    df = df.sort_values(by='clock') # Ensure data is sorted by time

                    # Get indicator name and units
                    itemid_of_indicator = df.iloc[0]['itemid']
                    name_of_indicator = "Unknown Indicator"
                    for name, value in dic.items():
                        if str(itemid_of_indicator) in value:
                            name_of_indicator = name
                            break
                    
                    unit_of_pointer = ""
                    try:
                         temp_cursor_unit = db.cursor()
                         temp_cursor_unit.execute("SELECT units FROM items WHERE itemid = %s", (itemid_of_indicator,))
                         unit_result = temp_cursor_unit.fetchone()
                         if unit_result and unit_result[0]:
                             unit_of_pointer = f" ({unit_result[0]})" # Add space and parentheses
                         temp_cursor_unit.close()
                    except pymysql.Error as e:
                        print(f"Warning: Could not fetch units for itemid {itemid_of_indicator}: {e}")


                    # Calculate time difference correctly
                    if len(df) > 1:
                         time_delta = df['clock'].iloc[-1] - df['clock'].iloc[0]
                         total_seconds = time_delta.total_seconds()
                         hours = int(total_seconds // 3600)
                         minutes = int((total_seconds % 3600) // 60)
                         timeset_str = f"{hours}시간 {minutes}분"
                    else:
                         timeset_str = "단일 시점"

                    df_describe = df['value'].astype(float).describe() # Ensure value is float for describe

                    # Format the descriptive answer
                    ai_response_content = (
                        f"{timeset_str} 동안의 '{name_of_indicator}' 지표는 다음과 같습니다{unit_of_pointer}:\n"
                        f"- 평균: {df_describe.get('mean', 'N/A'):.2f}\n"
                        f"- 표준편차: {df_describe.get('std', 'N/A'):.2f}\n"
                        f"- 최대값: {df_describe.get('max', 'N/A'):.2f}\n"
                        f"- 최소값: {df_describe.get('min', 'N/A'):.2f}"
                    )

                    # Create plot
                    fig = px.line(df, x='clock', y='value', title=f'{name_of_indicator} 시계열 데이터')
                    fig.update_layout(height=300, xaxis_title="시간", yaxis_title=f"값{unit_of_pointer}")

                else:
                    ai_response_content = "해당 조건에 맞는 데이터를 찾을 수 없습니다."

            except pymysql.Error as e:
                print(f"DB 실행 오류: {e}")
                ai_response_content = f"데이터 조회 중 오류가 발생했습니다: {e}"
            except Exception as e:
                print(f"데이터 처리/플로팅 오류: {e}")
                ai_response_content = f"결과 처리 중 오류가 발생했습니다: {e}"

        elif not is_correct_mapping:
             ai_response_content = f"SQL 생성 중 문제가 발생했습니다: {corrected_sql}" # Show error from make_tablecode_right
        else: # Not valid syntax or other issue
             ai_response_content = "죄송하지만, 유효한 SQL 쿼리를 생성하지 못했습니다. 질문을 다시 시도해 주시겠어요?"
             # Optionally create a default placeholder graph if needed
             # fig = go.Figure(...) # Your placeholder graph code

    except Exception as e:
        print(f"LLM 호출 또는 처리 중 예외 발생: {e}")
        st.error(f"LLM 통신 또는 응답 처리 중 오류 발생: {e}")
        ai_response_content = "죄송합니다, 요청을 처리하는 중 오류가 발생했습니다."
        fig = None

    # 5. Add AI response to history
    ai_message = {"role": "ai", "content": ai_response_content}
    if fig is not None:
        ai_message["fig"] = fig
    st.session_state.messages.append(ai_message)

    # 6. Rerun the script to update the UI immediately
    st.rerun()


# --- Close DB connection on script exit (optional but good practice) ---
# This part might not execute reliably in Streamlit's execution model
# Using st.connection is generally preferred for managing resources.
# def cleanup():
#     if 'db' in globals() and db.open:
#         db.close()
#         print("DB connection closed.")
# import atexit
# atexit.register(cleanup)